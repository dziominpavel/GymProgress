# Анализ потенциальных ошибок

Дата анализа: 2026-02-13.

## 1) Некорректная сортировка дат в журнале и статистике (высокий риск)
- `WorkoutEntry.date` хранится как строка формата `dd.MM.yyyy`.
- DAO сортирует записи SQL-выражением `ORDER BY date`, что лексикографически неверно для такого формата (например, `31.01.2026` будет «больше» `01.12.2026`).
- Из-за этого история тренировок и тренд в статистике могут отображаться в неправильном порядке.

**Где видно в коде:**
- Поле даты как `String` в сущности `WorkoutEntry`.
- Запросы `ORDER BY date` в `WorkoutDao`.
- Формат даты `dd.MM.yyyy` в `AddEntryDialog`.

**Рекомендация:** хранить дату в `Long` (epoch millis) или `LocalDate` через `TypeConverter`; для UI форматировать только на уровне отображения.

## 2) Потеря данных при миграции БД (высокий риск)
- В `AppDatabase` используется `fallbackToDestructiveMigration(dropAllTables = true)`.
- Любое несовпадение версии/схемы при обновлении удалит пользовательские данные.

**Рекомендация:** заменить на явные миграции `Migration(...)`, а destructive fallback оставить только для debug-сборок.

## 3) Отсутствие референциальной целостности между упражнениями и записями (средний риск)
- Запись тренировки хранит `exerciseName: String`, а не внешний ключ на `Exercise.id`.
- При удалении упражнения его исторические записи остаются «сиротскими» и продолжают участвовать в статистике.

**Рекомендация:**
- хранить `exerciseId` в `WorkoutEntry`;
- добавить `ForeignKey` с `onDelete = CASCADE` или мягкой деактивацией упражнения.

## 4) Возможны дубликаты упражнений (средний риск)
- Для `Exercise.name` нет `UNIQUE`-ограничения.
- UI не проверяет, что такое имя уже существует, поэтому можно создать несколько одинаковых упражнений.

**Рекомендация:**
- добавить индекс `unique = true` на имя (или составной ключ `name + muscleGroup`);
- сделать проверку в UI до вставки и показать понятное сообщение об ошибке.

## 5) Смешение источников данных в экране прогресса (средний риск)
- Список выбора упражнения в прогрессе (`exerciseNames`) берётся из `workout_entries` (`SELECT DISTINCT exerciseName`), а не из справочника `exercises`.
- Это означает, что удалённые из справочника упражнения всё ещё остаются в фильтре прогресса, а новые упражнения без записей не видны.

**Рекомендация:** явно определить продуктовую логику:
- либо строить список из `exercises`,
- либо из объединения `exercises + workout_entries` c меткой статуса.

## 6) Нет обработки ошибок операций БД в `ViewModel` (средний риск)
- Вставка/обновление/удаление выполняются в `viewModelScope.launch` без `runCatching`/обработки исключений.
- При `SQLiteConstraintException` (после добавления ограничений) или других ошибках пользователь не получит обратной связи.

**Рекомендация:** добавить состояние UI для ошибок (Snackbar/Toast), логирование и безопасные сценарии повторной попытки.

---

## Быстрый приоритет исправлений
1. Дата как `Long` + корректная сортировка в DAO.
2. Убрать destructive migration в release.
3. Ввести связь `exerciseId` и внешние ключи.
4. Добавить уникальность упражнений и обработку ошибок на уровне UI/ViewModel.

## Что проверить первым делом (быстрый чек-лист)
- Открыть журнал и убедиться, что записи сортируются корректно при переходе между месяцами/годами.
- Проверить обновление приложения со старой БД без потери данных.
- Удалить упражнение и убедиться, что связанные записи обрабатываются предсказуемо.
- Попробовать добавить дубликат упражнения и проверить UX ошибки.
